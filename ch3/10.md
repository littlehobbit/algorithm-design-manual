## Задание 10

### "Первый лучший"
Эвристический алгоритм "первый лучший" с временем выполнения О(nlogn) может быть реализован на основе сбалансированного (или нет) бинарного дерево поиска, содержащее ящики. 

Ключем в данном случае будет выступать **свободное** место в ящике.

```
function first_best(root, weights[n])
    for i = 1 ... n
        node = successor(root, weights[i])
        delete(root, node)
        if node == null
            create new node with free = 1
        node.free = node.free - weights[i]
        insert(root, node)
```

Процесс удаления и вставки записи схож с механизмом просеивания: мы берем нужную нам запись в дереве, извлекаем её, изменяем, а после - вставляем на новое место.

----------------------------------------

### "Первый худший"
По структуре данных данный алгоритм схож с предыдущим, однако вместо операции `successor`, будет использоваться операция `max`, т.к. для нового объекта после его помещения останется наибольший свободный объем только при наибольшем свободном ящике.

```
function first_best(root, weights[n])
    for i = 1 ... n
        node = max(root)
        delete(root, node)
        if node == null or node.free < weights[i]
            create new node with free = 1
        node.free = node.free - weights[i]
        insert(root, node)
```

После каждого алгоритма, для просчета количества коробок достаточно просто посчитать количество узлов.