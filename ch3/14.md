### Задание 14
Данное задание отличается от предыдущего только тем, что диапазон значений ключей, вместо заранее известных `[0 ... n]`, предполагает использование динамического диапазона, который зависит от вставляемых ключей, т.е `[min key ... max key]`. 

В задании все так же используется дерево, ключами которого выступают диапазоны, а значения - сумма записей в этом диапазоне ключей. От каждого узла дерева исходит левое поддерево с левой половиной диапазона, и правое поддерево с правой половиной.

Пример:
- [min key ... max key]
  - [min key ... (min + max) / 2]
    - ...
  - ( (min + max) / 2 ... max]
    - ...

Такие функции, как `partial-sum(k)` и `add(k, y)` остаются аналогичными функциям из прошлого задания, но вот функция добавления `insert(k, y)` и удаления `delete(k)` следует разобрать подробнее.

#### `insert(k, y)`
При вставке нового элемента с ключем **k**, следует рекурсивно (как обычно по дереву) пройти к месту вставки и вставить новое значение. 

После вставки нужно провести некоторые действия:
- Пройти по ветви обратно к корню, попутно увеличивая значения узлов
- Если вставленный ключ меньше `min key` или больше `max key`, то при проходе обратно вверх по ветви обновлять данные значения.

Код ниже **описывает** алгоритм
```c++
void insert(key_type k, data y) {
    int id = 0; // start id
    key_type global_min = Heap[0].min;
    key_type global_max = Heap[0].max;

    // find place to insert
    while (Heap[id] != NULL) {
        if (Head[2 * id].min <= k && k <= Head[2 * id].min) {
            id = 2 * id;
        } else {
            id = 2 * id + 1;
        }
    }

    // insert new node
    Heap[id] = new node(k, i);

    // go back
    while (id != 0) {
        id = id / 2;
        if (k < global_min) Heap[id].min = k;
        if (k > global_max) Heap[id].max = k;
        Heap[id].sum += y;
    }
}
```
----------

#### `delete(k)`
Удаление записи (неужели) обратен вставке, но при этом:
- При проходе от удаленного узла по ветви к корню от значений сумм отнимается значение данных удаленного узла.
- Если ключ удаленного узла был `min key` или `max key`, то при проходе от него к корню нужно изменить диапозон ключей узлов на основе диапазона родительского узла удаленного. (Если k = `min key`, то заменить все левые края по пути к корню на левый край родительского, а при k = `max key` аналогичсно заменить на правый край)